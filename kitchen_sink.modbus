# starting address, number of registers to read OR value to write, True to write|False to read, delay after, # of iterations, note
"BIT", 2, False, 0.5, 2, "Should return 2-element array of integers (twice) with a 1/2-second delay between",
"WARMUP_STATE", 99, False, 0.1, 1, "Attempt to read past end of registers",
#   "WARMUP_STATE", 37, True, 0.1, 1, "Attempt to write to read-only register",
"START_VOLTAGE", 1, False, .1, 1, "",
# "START_DELAY", 1, False, 0.1, 1, "",
# "STOP_VOLTAGE", 1, False, 0.1, 1, "",
# "STOP_DELAY", 1, False, 0.1, 1, "",
# "GEN_CONTROL", 1, False, 1, 1, "",

"START_VOLTAGE", 2096, True, 1
"BOGUS", 2096, True, 1, 9999, "Write new start voltage 20.96",
"START_VOLTAGE", 2096, True, 1, 9999, "Write new start voltage 20.96",
"STOP_VOLTAGE", 2400, True, 0.1, 1, "Write new stop voltage 24.00",
"START_DELAY", 208, True, 0.1, 1, "Write new start delay 23 s",
"STOP_DELAY", 192, True, 0.1, 1, "Write new stop delay 29 s",
"GEN_CONTROL", 0, True, 1, 1, "Write new gen control 0",

"START_VOLTAGE", 4, False, .1, 300, "",
# "START_DELAY", 1, False, 0.1, 1,"",
# "STOP_VOLTAGE", 1, False, 0.1, 1,"",
# "STOP_DELAY", 1, False, 0.1, 1,"",
# "GEN_CONTROL", 1, False, .1, 1, "",

"CRANK_TIMEOUT", 1, False, 0.1, 1, "",
"REGULATED_VOLTAGE", 1, False, 0.1, 1, "",
"MAX_CHARGING_CURRENT", 1, False, 0.1, 1, "",
"LVCO", 1, False, 0.1, 1, "",
"BUS_VOLTAGE", 1, False, 0.1, 1, "",
"CURRENTS", 1, False, 0.1, 1, "",
"AGS_STATUS", 1, False, .1, 1, "",
"AC_INPUT", 1, False, .1, 1, "",
"START_VOLTAGE", 13, False, 1, 1,
 "Returns all registers starting with START_VOLTAGE and ending with AC_INPUT",
# #   "BIT", BIT_EXECUTE, True, normal_delay, 1, 'BIT_EXECUTE request should return None' ],
#   "BIT", BIT_EXECUTE, False, normal_delay, 1, f'read should return value just written' ],
#   "BIT", 1, False, normal_delay, 18, 'should return BIT_EXECUTE(1) for a bit, then BIT_OK(=0) (see RMAGS.h)'],
#   "BIT", BIT_EXECUTE, False, normal_delay, 1, f'should have cleared and be back to 0' ],
#   "TOTAL_ERRORS", 1, False, normal_delay, 1, 'should return 0 unless there was an error'],
#    "LOG_HEAD", 3, False, normal_delay, 1, 'should return 0 unless there was an error'],
#   "LOG_LEVEL", 8, False, normal_delay, 1, 'should return the last log entry'],
#   "LOG_HEAD", 3, False, normal_delay, 1, 'should return 0 unless there was an error'],

#   "TOTAL_REGS_SIZE", 1, False, normal_delay, 1, f'should return the number of registers ({regs["TOTAL_REGS_SIZE"})'],
#   "LOG_COMMAND", LOG_CLEAR, True, normal_delay, 1, 'should clear the log'],
# #  "TOTAL_ERRORS", 1, False, normal_delay, 1, 'should return 0 unless there was an error'],
#        "LOG_HEAD", 3, False, normal_delay, 1, 'head, tail, and status'],
#
#    "LOG_LEVEL"+1, 7, False, normal_delay, 1, 'should return the entry in 1st slot, skipping the log level, without clearing it'],
#    "LOG_LEVEL"+LOG_ENTRY_SIZE, 8, False, normal_delay, 1, 'should return the entry in 2nd slot without clearing it'],
#    "LOG_LEVEL"+LOG_ENTRY_SIZE*2, 8, False, normal_delay, 1, 'should return the entry in 3rd slot without clearing it'],
#    "LOG_LEVEL"+LOG_ENTRY_SIZE*3, 8, False, normal_delay, 1, 'should return the entry in 4th slotwithout clearing it'],
#    "LOG_LEVEL", 8, False, normal_delay, 1, 'should return the last log entry'],
# #   "LOG_LEVEL"+1, 7, False, normal_delay, 2, 'should return the entry in 1st slot, skipping the log level, and it should have been cleared and tail incremented'],
#    "LOG_HEAD", 3, False, normal_delay, 1, 'head, tail, and status'],
